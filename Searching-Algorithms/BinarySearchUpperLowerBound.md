# Lower Bound / Upper Bound
- **정렬** 된 데이터에서 탐색을 진행해야 한다.
- 이진 탐색이 **원하는 값 k를 찾는 과정** 이라면,
- Lower Bound는 **원하는 값 k이상이 처음 나오는 위치를 찾는 과정**
- Upper Bound **원하는 값 k이하가 처음 나오는 위치를 찾는 과정** 이라고 할 수 있다.

- 다음과 같이 정렬된 데이터가 있다고 가정해 보자.

```cpp
int data[] = {
  -520, -235, -122, -121, -119,
  -108, -80, -70, -30, -15, -3, -3, -3, -2,
  2, 5, 5, 7, 9, 15, 19, 30, 250,
  256, 260, 341, 351, 380, 490, 500, 501
};
```

- 이 상태에서 -100 과 300 사이에 있는 몇개의 데이터가 있는지 알아내고자 한다면, 어떻게 해야 할까?
- 데이터에 -100과 300이라는 숫자는 없기 때문에, 이진탐색은 포기해야 하는가?
- 아니다.
- -100이 이상이 데이터에서 처음 나오는 위치와 300 이하가 데이터에서 처음 나오는 위치를 찾으면 된다.
- 이때, -100이 처음 이상이 처음 나오는 위치를 Lower Bound라고 하고,
- 300 이하가 처음 나오기 시작하는 위치를 Upper Bound라고 한다.
- 즉, 우리가 찾고자 하는 데이터의 범위의 아래로 유계(Lower Bound)와 위로 유계(Upper Bound)를 찾으면 되는 것이다.
- 쉽게 풀어쓰자면, 데이터의 경계를 찾는 것인데, 경계가 영어로 Bound이다.
- 유계, 있을 유, 경계 계
- 뜻풀이는 이쯤에서 그만두고, 코드를 작성해 보자.


- 먼저, Lower Bound를 찾기 위하느 코드는 아래와 같다.
- 이진탐색과 코드는 동일하다. 단지 차이가 있다면, lower라는 인자가 우리가 찾고자 하는 데이터가 아니라는 점이다.
- low라는 인자는 단지 우리가 찾고자 하는 데이터의 하한 기준선일 뿐이다.

```cpp

int Binary_Search_Lower(int s, int e, int lower, int * data){
  int m, lower_bound = -1;

  while(s <= e){
    m = (s + e)/2;
    if(lower <= data[m]){
      lower_bound = m;
      e = m - 1;
    } else s = m + 1;
  }
  return lower_bound;
}
```

- 다음으로, Upper Bound를 찾기 위하느 코드는 아래와 같다.
- 이진탐색과 코드는 동일하다. 단지 차이가 있다면, upper라는 인자가 우리가 찾고자 하는 데이터가 아니라는 점이다.
- upper라는 인자는 단지 우리가 찾고자 하는 데이터의 상한 기준선일 뿐이다.
- Lower Bound를 찾는 함수와 다른 점이 있다면, if 조건문을 만족할때 하는 행위가 살짝 다르다는 점이다.
- Lower Bound 코드에서는 데이터의 하한 기준선이 데이터의 앞 절반에 있으면, 끝 요소의 인덱스를 줄여나가며 탐색을 진행했지만,
- Upper Bound 코드에서는 데이터의 상한 기준선이 데이터의 뒤 절반에 있으면, 첫 요소의 인덱스를 늘려나가며 탐색을 진행했다는 점이다.
- 차이점을 눈으로 확인하자.

```cpp
int Binary_Search_Upper(int s, int e, int upper, int * data){
  int m, upper_bound = -1;
  while(s <= e){
    m = (s + e)/2;
    if(data[m] <= upper){
      upper_bound = m;
      s = m + 1;
    } else e = m - 1;
  }
  return upper_bound;
}
```
