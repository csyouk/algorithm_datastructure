문제 설명
현진이는 농부가 되고 싶어서 가로 5m, 세로 5m 크기의 땅을 구입 하였다. 현진이는 1m * 1m 의 크기의 땅으로 구역을 나누었다. 이 경우 좌측 상단은 (1 , 1)이고 우측 하단은 (5, 5)이다. 즉, 현진의 땅은 아래와 같이 나타낼 수 있다.

(1,1) (1,2) (1,3) (1,4) (1,5)
(2,1) (2,2) (2,3) (2,4) (2,5)
(3,1) (3,2) (3,3) (3,4) (3,5)
(4,1) (4,2) (4,3) (4,4) (4,5)
(5,1) (5,2) (5,3) (5,4) (5,5)

이렇게 25칸의 땅이 존재 하는데 현진이는 사과 나무를 심기로 하였다. 그러나 K개 구역에는 거대한 바위가 박혀 있기 때문에(0 <= K <= 22, K는 짝수), 그 지역에는 사과 나무를 심지 못한다. 그리고 그가 사과 나무를 심을 때 좀 더 재미있는 방법으로 하기 위해서 친구 영진이와 함께 일을 하려고 한다. 현진이는 (1, 1) 에서 사과 나무를 심기 시작 하고 영진이는 (5, 5)에서부터 나무 심기를 시작 하였다. 단 (1, 1) 과 (5, 5) 에는 항상 바위가 없기 때문에 나무를 심을 수 있다.
나무를 심을 때, 그들이 소요하는 시간은 일정 하다. 그래서 그들은 나무를 심을 수 있는 모든 땅에 나무를 심은 뒤 마지막 한곳에서 만나서 같이 나무를 심으려고 한다. K개의 바위 위치가 주어질 때 그들의 방법으로 나무를 심을 방법이 몇 가지인지 알아보자.
단 이미 나무를 심은 곳은 이동 할 수 없고, 현재 위치에서 상하좌우로 인접한 지역 이외에는 이동이 불가능 하다. 또한 거대한 바위가 있는 지역도 이동이 불가능 하고, 그들은 마지막 장소를 제외하고는 만나면 안 된다.


입력
첫 번째 줄에는 거대한 바위의 개수 K가 주어진다. 두 번째 줄부터 K+1 줄까지 바위의 행과 열이 주어진다.
출력
그들의 방법대로 나무를 심을 수 있는 방법의 개수를 출력 하시오.
입력 예시
4
3 2
3 3
3 4
3 1
출력 예시
1
도움말
입력으로 주어진 상황을 그림으로 표현 하면 아래와 같다. 점(.)은 사과 나무를 심을 수 있는 칸, h는 현진이 y 는 영진이 의 위치이다. x 는 바위의 위치다.

h  .  .  .  .
.  .  .  .  .
x  x  x  x  .
.  .  .  .  .
.  .  .  .  y

아래의 그림은 그들의 방법으로 나무를 심는 방법 이다. 이 입력의 경우에는 아래와 같이 한가지의 경우 밖에 없다.

h   h---h   h---h
|   |   |   |   |
h---h   h---h   h
                |
x   x   x   x  y/h
                |
y---y---y---y---y
|
y---y---y---y---y


//
//  현진이의농장.c
//  codeground
//
//  Created by youkchangsu on 2017. 10. 6..
//  Copyright © 2017년 youkchangsu. All rights reserved.
//
//
/*
 조건
 1. 25개의 칸.
 2. 짝수개의 바위(0 ~ 22)
 3. 현진이는 1,1   / 영진이는 5,5
 4. 모든 땅에 나무를 심어야 함.
 5.
*/
#if 1
#include <stdio.h>
#define DIRS 4
int N;
typedef struct {
  int i,j,dis;
} Pos;
Pos rocks[30];
Pos h, y;
int rp, wp,target_dis, cnt;
int map[5+10][5+10];
int visited[5+10][5+10];

int di[DIRS] = {0,-1,0,1};
int dj[DIRS] = {-1,0,1,0};

void Init(void){
  h.i = h.j = 1;
  y.i = y.j = 5;
  h.dis = y.dis = 0;
  target_dis = (24 - N);
  visited[h.i][h.j] = 1;
}

void DFS(int i, int j, int dis){
  int k,ni,nj;

  if(i == y.i && j == y.j && dis == target_dis){
    cnt++;
    return;
  }

  for (k = 0; k < DIRS; k++) {
    ni = i + di[k];  nj = j + dj[k];
    if(ni < 1 || ni > 5 || nj < 1 || nj > 5) continue;
    if(visited[ni][nj] || map[ni][nj]) continue;
    visited[ni][nj] = 1;
    DFS(ni, nj, dis + 1);
    visited[ni][nj] = 0;
  }
}

int main(void)
{
  int i;
  
  scanf("%d", &N);
  for (i=1; i<=N; i++) {
    scanf("%d %d", &rocks[i].i, &rocks[i].j);
    map[rocks[i].i][rocks[i].j] = 1;
  }
  Init();

  DFS(h.i, h.j, h.dis);

  printf("%d", cnt);

  return 0;
}
#endif
