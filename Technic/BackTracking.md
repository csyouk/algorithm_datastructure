# Back Tracking
- **가능한 모든 경우를 탐색하는 방법.** <- 진리.
- DFS에서 time limit은 매우 좋은 신호. wrong answer가 없다는 뜻.

- 아이디어성 문제가 많다.
  - 증가되는 n은 무엇인지?
  - 종료조건은 무엇인지?
  - 트리 구조는 어떻게 생겼는지?
  - 종료 조건이 n에 의해서 결정됨.

- 문제 풀이 절차.
  - 1단계. 가능한 모든 단계 설계.
  - n을 정의하고 Tree를 그린다.
  - 트리를 그려본 후, time limit을 고려해야 한다.
  - 종료 조건 도출.(종료 조건은 )

- 테스트는 이진 트리 형태가 많이 나온다.
- 가지를 무엇으로 잡을것이냐?

- 재귀에서 전역변수의 사용은 로직을 증가시키는 행위이다.

- 가지치기는 함수를 들어가자마자.

- **경우의 수 문제는 매우 어려운 문제이다.** (가지를 칠수 없기 때문.)
- n은 무조건 종료조건과 관계되는 것으로 잡는다.

- DFS가 어려워지는 경우의 문제는, check함수가 어려워지거나, 정답 후 처리가 어려워지는 경우이다.

- DFS인지 아닌지를 확인해보고 싶다. ==> 복잡도를 계산해야한다.

```cpp
DFS(n, ...){

  // 종료조건 <= n에 관련된 것으로 작성
  DFS(n + 1, ...);
}


```


### 주사위 문제
- n : 주사위 던지는 회수(순서)
- 가능한 **모든 경우** -> 정답 // 대원칙!
- 동그라미에 n값
  - 화살표에 선택한 경우를 작성.
  - 화살표가 호출 횟수가 되는 셈.

```cpp

#include <stdio.h>
int N, M;
int sol[7 + 10]; // 정답이 들어가 있는 배열.
void DFS(int n, int sum){
	int i;
	if (n > N) { // 종료 조건
		if (sum == M){ // 이 곳에 정답과 관련된 로직을 처리한다.
			for (i = 1; i <= N; i++)
			{
				printf("%d ", sol[i]);
			}
			printf("\n");
		}
		return;
	}
	for (i = 1; i <= 6; i++)
	{
		sol[n] = i;
		DFS(n + 1, sum + i);
	}
}

int main(void)
{

	// 여기서부터 작성
	scanf("%d %d", &N, &M);

	DFS(1, 0);

	return 0;
}
```
