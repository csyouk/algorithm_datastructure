# Insertion Sort
## 용어
- 요소수(index of element) : 배열기반의 자료구조에 접근하기 위한 수.
- 삽입 정렬의 아이디어는 다음과 같다.
  - 정렬되지 않은 배열기반의 순차적인 데이터형태가 있을 때 사용한다.
  - 정렬되지 않은 배열의 모든 요소를 첫 요소부터 끝요소까지 훑어나가며 각 요소의 위치에서
  이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.

## 장점
- 구현이 간단하다.

## 단점
- 배열이 길어질수록 효율이 떨어진다.
- 선택, 버블 정렬보다는 빠르지만, time-complexity는 여전히 O(n^2)이다.


다음 C 코드로 삽입 정렬의 정렬방식을 이해해보자.


```cpp

다음과 같은 데이터가 있다고 가정해보자.
typedef struct {
  int id;
  int score;
  char name[10];
} SCORE;
#define MAX_ST 20
SCORE exam[MAX_ST];

함수의 원형은 다음과 같다.
int Sort_Insertion(SCORE * d, int order, int(*comp)(SCORE * x, SCORE * y));

parameter분석을 해보자.
- d는 정렬할 대상인 배열의 주소이다.
- order는 내림차순, 오름차순 옵션을 넘긴다.(1 : 오름차순, -1 : 내림차순)
- comp는 포인터 함수이다. 정렬의 기준에 해당하는 함수를 넘겨준다.(Id, Score, Name)

그리고, 추가로 규칙을 더해보자면, exam배열의 요소 중 id가 0인 것은, 데이터가 없는 것으로 간주하자.


삽입 정렬의 구조는 3중 loop으로 되어 있다.
가장 바깥 loop부터 차례대로, i, j, k loop 으로 반복문의 이름을 명명한다.
삽입 정렬은 실제로 데이터가 몇개 들어가 있는지, 데이터의 크기를 미리 알 필요가 없다.

===> 1 단계
i loop는 다음과 같이 표현할 수 있다. 정렬대상을 하나씩 늘려나가면서, 정렬을 시킨다.
이때 i의 시작 요소수가 1인 것에 주의하라.
i loop의 요소수의 이전것은 정렬되어 있는 것으로 간주한다.  
int i;
...
for (i = 1; i < MAX_ST; i++) {

}

===> 2단계
j loop는 기준점이 되는 i 인덱스로부터 비교대상을 찾아서 삽입 위치를 찾는 것이다.
=> i-1의 위치부터 한단계씩 인덱스를 낮춰가며 0이 될때까지 loop를 돌린다.
=> 요소수 0부터 시작하여 i-1의 위치까지 비교해가며 삽입 위치를 찾는다.
j의 목적은 삽입 위치를 찾는 것이다.
삽입할 위치를 찾게 되면, 반복문을 중단 시킨 후, j의 값을 가지고 j-loop을 빠져나온다.
코드로 나타내면 다음과 같다.
이때 주의할 점은, 비교하는 기준이 i번째 요소가 된다는 것이다.

int j;
SCORE tmp;
...
for (j = 0; j < i; j++) {
  if(comp(&d[j], &d[i]) == order) break;
}

===> 3단계
k loop를 돌기 전에 할 일은, i번째 요소에 있던 값을 임시로 tmp로 벡업시켜놓고,
i-1 의 위치에서 부터 하나씩 요소수를 감소해 나가며, data를 뒤로 미는 작업을 한다.
즉, i-1 위치에 있던 데이터는 i번째 방으로 옮기고,
i-2 는 i-1 로
i-3 은 i-2 로... 한다.

마지막으로, 삽입할 위치인 j번째 방에는 벡업해 놓았던 값을 넣는다.
int k;
...

tmp = d[i];
for (k = i; k < count; k++) {
  d[k] = d[k-1];
}
d[j] = tmp;


위의 3단계를 정리해보면 다음과 같다.

int Sort_Insertion(SCORE * d, int order, int(*comp)(SCORE * x, SCORE * y))
{
	// i는 정렬대상, 데이터의 크기를 결정함.
	// j는 비교대상
	// k는 데이터를 뒤로 미는 작업을 할 때 쓰는 제어 변수이다.
	for (i = 1; i < MAX_ST; i++)
	{
		if (d[i].id == 0) break; // id가 0이면 더 이상 데이터가 없는 것으로 간주한다.
		for (j = 0; j < i; j++)
		{
			// i와 j를 비교하며, i번째 요소의 값보다 큰 j번째 요소를 맞닥뜨렸을 때,
			// 데이터를 밀기 시작한다.
			if (comp(&d[j], &d[i]) == order) break;
		}

		tmp = d[i];
		for (k = i; k > j; k--)
		{
			d[k] = d[k - 1];
		}
		d[j] = tmp;
	}

	return i;
}





















```
